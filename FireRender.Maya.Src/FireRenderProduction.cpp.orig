#include "FireRenderProduction.h"
#include "Context/TahoeContext.h"
#include <tbb/atomic.h>
#include <maya/MRenderView.h>
#include <maya/MViewport2Renderer.h>
#include <maya/MGlobal.h>
#include "FireRenderThread.h"
#include "AutoLock.h"
#include <thread>
#include <maya/MCommonRenderSettingsData.h>
#include <maya/MRenderUtil.h>

#include "FireRenderGlobals.h"
#include "FireRenderUtils.h"
#include "RenderStampUtils.h"

#include "TileRenderer.h"
#include "Athena/athenaWrap.h"

#include "RenderStampUtils.h"
#include "GlobalRenderUtilsDataHolder.h"
#include <iostream>
#include <fstream>

#include "Context/ContextCreator.h"

#include <functional>
#include <clocale>
#include <chrono>
#include <ctime>

#include "common.h"

#if defined(_WIN32)
#include "athenaSystemInfo_Win.h"
#endif

#if defined(__APPLE__)
#include "athenaSystemInfo_Mac.h"
#endif  // defined(__APPLE__)

using namespace std;
using namespace std::chrono;
using namespace RPR;
using namespace FireMaya;

// Life Cycle
// -----------------------------------------------------------------------------
FireRenderProduction::FireRenderProduction() :
	m_width(0),
	m_height(0),
	m_isRunning(false),
	m_isPaused(false),
	m_isRegion(false),
	m_renderStarted(false),
	m_needsContextRefresh(false),
	m_progressBars(),
	m_rendersCount(0)
{
	m_renderViewUpdateScheduled = false;
}

// -----------------------------------------------------------------------------
FireRenderProduction::~FireRenderProduction()
{
	if (m_isRunning)
		stop();
}


// Public Methods
// -----------------------------------------------------------------------------
bool FireRenderProduction::isRunning()
{
	return m_isRunning;
}

// -----------------------------------------------------------------------------
bool FireRenderProduction::isError()
{
	return m_error.check();
}

bool FireRenderProduction::isCancelled() const
{
	return m_cancelled;
}

// -----------------------------------------------------------------------------
void FireRenderProduction::updateRegion()
{
	// Check that a region was specified
	// and it is not the full render area.
	m_isRegion =
		!m_region.isZeroArea() &&
		!(m_region.getWidth() == m_width && m_region.getHeight() == m_height);

	// Default to the full render view if the region is invalid.
	if (!m_isRegion)
		m_region = RenderRegion(m_width, m_height);

	// Ensure the pixel buffer is the correct size.
	m_pixels.resize(m_region.getArea());

	// Instruct the context to render to a region if required.
	if (m_isRunning)
	{
		FireRenderThread::RunOnceProcAndWait([this]()
		{
			// was causing deadlock: AutoMutexLock contextLock(m_contextLock);
			m_isRegion = m_contextPtr->setUseRegion(m_isRegion);

			if (m_isRegion)
			{
				m_contextPtr->setRenderRegion(m_region);
			}

			// Invalidate the context to restart the render.
			m_contextPtr->setDirty();
		});
	}

	// Restart the Maya render if currently running.
	if (m_isRunning)
		startMayaRender();
}

// -----------------------------------------------------------------------------
void FireRenderProduction::setResolution(unsigned int w, unsigned int h)
{
	m_width = w;
	m_height = h;
}

void FireRenderProduction::setRenderRegion(RenderRegion & value)
{
	m_region = value;
}

// -----------------------------------------------------------------------------
void FireRenderProduction::setCamera(MDagPath& camera)
{
	m_camera = camera;
	MRenderView::setCurrentCamera(camera);
}

// -----------------------------------------------------------------------------
bool FireRenderProduction::start()
{
	MStatus status;

	bool showWarningDialog = false;

	if (GlobalRenderUtilsDataHolder::GetGlobalRenderUtilsDataHolder()->IsSavingIntermediateEnabled())
	{
		GlobalRenderUtilsDataHolder::GetGlobalRenderUtilsDataHolder()->UpdateStartTime();
		std::remove(std::string(GlobalRenderUtilsDataHolder::GetGlobalRenderUtilsDataHolder()->FolderPath() + "time_log.txt").c_str());
	}

	// Read common render settings.
	MRenderUtil::getCommonRenderSettings(m_settings);

	// Read RPR globals.
	m_globals.readFromCurrentScene();
	MString renderStamp;
	if (m_globals.useRenderStamp)
		renderStamp = m_globals.renderStampText;

	m_aovs = &m_globals.aovs;

	int contextWidth = m_width;
	int contextHeight = m_height;

	RenderRegion region = m_region;

	if (m_globals.tileRenderingEnabled)
	{
		contextWidth = m_globals.tileSizeX;
		contextHeight = m_globals.tileSizeY;

		region = RenderRegion(contextWidth, contextHeight);
	}

	//m_isRegion = true;

	auto ret = FireRenderThread::RunOnceAndWait<bool>([this, &showWarningDialog, contextWidth, contextHeight]()
	{
		{
			AutoMutexLock contextCreationLock(m_contextCreationLock);

			m_contextPtr = ContextCreator::CreateAppropriateContextForRenderType(RenderType::ProductionRender);
			m_contextPtr->SetRenderType(RenderType::ProductionRender);
		}

		m_contextPtr->enableAOV(RPR_AOV_OPACITY);
		if (m_globals.adaptiveThreshold > 0.0f)
		{
			m_contextPtr->enableAOV(RPR_AOV_VARIANCE);
		}

		m_aovs->applyToContext(*m_contextPtr);

		// Stop before restarting if already running.
		if (m_isRunning)
			stop();

		// Check dimensions are valid.
		if (m_width == 0 || m_height == 0)
			return false;

		m_contextPtr->setCallbackCreationDisabled(true);
		if (!m_contextPtr->buildScene(false, false, false, false))
		{
			return false;
		}

		m_aovs->setFromContext(*m_contextPtr);

		m_needsContextRefresh = true;
		m_contextPtr->setResolution(contextWidth, contextHeight, true);
		m_contextPtr->setCamera(m_camera, true);

		m_contextPtr->setUseRegion(m_isRegion);

		if (m_contextPtr->isFirstIterationAndShadersNOTCached())
			showWarningDialog = true;	//first iteration and shaders are _NOT_ cached

		if (m_isRegion)
			m_contextPtr->setRenderRegion(m_region);

		return true;
	});

	if (ret)
	{
		// Initialize the render progress bar UI.
		m_progressBars = make_unique<RenderProgressBars>(m_contextPtr->isUnlimited());

		FireRenderThread::KeepRunningOnMainThread([this]() -> bool { return mainThreadPump(); });

		// Allocate space for region pixels. This is equivalent to
		// the size of the entire frame if a region isn't specified.

		// Setup render stamp
		m_aovs->setRenderStamp(renderStamp);

		// Allocate memory for active AOV pixels and get
		// the AOV that will be displayed in the render view.
		m_aovs->setRegion(region, contextWidth, contextHeight);
		m_aovs->allocatePixels();
		m_renderViewAOV = &m_aovs->getRenderViewAOV();

		if (showWarningDialog)
		{
			rcWarningDialog.show();
		}

		// Start the Maya render view render.
		startMayaRender();

		// Ensure the scheduled update flag is clear initially.
		m_renderViewUpdateScheduled = false;

		m_isRunning = true;

		refreshContext();
		m_needsContextRefresh = false;

		m_contextPtr->setStartedRendering();

		// Start the render
		FireRenderThread::KeepRunning([this]()
		{
			try
			{
				if (m_globals.tileRenderingEnabled)
				{
					RenderTiles();
					stop();
					m_isRunning = false;
				}
				else
				{
					m_isRunning = RunOnViewportThread();
				}
			}
			catch (...)
			{
				// We should stop rendering if some exception(error on core side) occured. It will close all progress bars etc
				stop();
				m_isRunning = false;
				m_error.set(current_exception());
			}

			return m_isRunning;
		});
	}

	return ret;
}

// -----------------------------------------------------------------------------
bool FireRenderProduction::pause(bool value)
{
	m_isPaused = value;

	if (m_isPaused)
	{
		m_contextPtr->state = FireRenderContext::StatePaused;
	}
	else
	{
		m_contextPtr->state = FireRenderContext::StateRendering;

		m_needsContextRefresh = true;
	}

	return true;
}

// -----------------------------------------------------------------------------
bool FireRenderProduction::stop()
{
	if (m_isRunning)
	{
		if (m_contextPtr)
			m_contextPtr->state = FireRenderContext::StateExiting;

		stopMayaRender();

		FireRenderThread::RunProcOnMainThread([&]()
		{
			m_stopCallback(m_aovs, m_settings);
			m_progressBars.reset();

			std::string renderStampText = RenderStampUtils::FormatRenderStamp(*m_contextPtr, "\\nFrame: %f  Render Time: %pt  Passes: %pp");

			MString command;
			command.format("renderWindowEditor -e -pcaption \"^1s\" renderView", renderStampText.c_str());

			MGlobal::executeCommandOnIdle(command);

			RenderStampUtils::ClearCache();
		});

		if (m_contextPtr)
		{
			if (FireRenderThread::AreWeOnMainThread())
			{
				// Try-lock context lock. If can't lock it then RPR thread is rendering - run item queue
				while (!m_contextLock.tryLock())
				{
					FireRenderThread::RunItemsQueuedForTheMainThread();
				}

				m_contextPtr->cleanScene();

				m_contextLock.unlock();
			}
			else
			{
				std::shared_ptr<FireRenderContext> refToKeepAlive = m_contextPtr;
				m_contextPtr.reset();

				refToKeepAlive->cleanSceneAsync(refToKeepAlive);
			}
		}
	}

	return true;
}

// -----------------------------------------------------------------------------
template <class T>
void WriteAthenaFieldAsString(const std::string& fieldName, const T& data)
{
	std::ostringstream ss;
	ss << data;
	AthenaWrapper::GetAthenaWrapper()->WriteField(fieldName, ss.str());
}

template <class T>
void WriteAthenaField(const std::string& fieldName, const T& data)
{
	AthenaWrapper::GetAthenaWrapper()->WriteField(fieldName, data);
}

#if defined(OSMac_)
int getNumCPUCores()
{
	int numCPU;
	std::size_t len = sizeof(numCPU);

	/* set the mib for hw.ncpu */
	int mib[] = { CTL_HW, HW_AVAILCPU }; // alternatively, try HW_NCPU;

	/* get the number of CPUs from the system */
	sysctl(mib, sizeof(mib) / sizeof(int), &numCPU, &len, NULL, 0);

	if (numCPU < 1)
	{
		mib[1] = HW_NCPU;
		sysctl(mib, sizeof(mib) / sizeof(int), &numCPU, &len, NULL, 0);
		if (numCPU < 1)
			numCPU = 1;
	}

	return numCPU;
}

#elif defined(__linux__)
int getNumCPUCores()
{
	int numCPU = sysconf(_SC_NPROCESSORS_ONLN);

	return numCPU;
}
#endif

void FireRenderProduction::UploadAthenaData()
{
	// operating system
#if defined(_WIN32)
	std::string osName;
	std::string osVersion;
	getOSName(osName, osVersion);
	WriteAthenaField("OS Name", osName);
	WriteAthenaField("OS Version", osVersion);

	// - Get the timezone info.
	std::string timezoneName;
	getTimeZone(timezoneName);
	WriteAthenaField("OS TZ", timezoneName);

#elif defined(__APPLE__)
    char buffer[1024];

    getTimeZone(buffer, sizeof(buffer)/sizeof(buffer[0]));
    WriteAthenaField("OS TZ", buffer);

    getOSName(buffer, sizeof(buffer)/sizeof(buffer[0]));
    WriteAthenaField("OS Name", buffer);

    getOSVersion(buffer, sizeof(buffer)/sizeof(buffer[0]));
    WriteAthenaField("OS Version", buffer);
#elif defined(__linux__)
	WriteAthenaField("OS Name", "Linux");
#endif

	// os arch
	WriteAthenaField("OS Arch", "64bit");

	// plug-in version
	WriteAthenaFieldAsString("ProRender Plugin Version", PLUGIN_VERSION);

	// core version
#ifdef RPR_VERSION_MAJOR_MINOR_REVISION
	std::ostringstream oss;
	oss << RPR_VERSION_MAJOR << "." << RPR_VERSION_MINOR << RPR_VERSION_REVISION;
#else
	int mj = (RPR_API_VERSION & 0xFFFF00000) >> 28;
	int mn = (RPR_API_VERSION & 0xFFFFF) >> 8;

	std::ostringstream oss;
	oss << std::hex << mj << "." << mn;
#endif

	WriteAthenaField("ProRender Core Version", oss.str());

	// host application
	WriteAthenaField("Host App", "Maya");

	// render time
<<<<<<< HEAD
	WriteAthenaField("Seconds spent on render", m_context->m_secondsSpentOnLastRender);
=======
	header.str(std::string());
	header.clear();
	data_field.str(std::string());
	data_field.clear();
	data_field << m_contextPtr->m_secondsSpentOnLastRender;
	header << "Seconds spent on render";
	pAthenaWrapper->WriteField(header.str(), data_field.str());
>>>>>>> master

	// device used
	// - CPU Name
	std::string CPUName = RenderStampUtils::GetCPUNameString();
	WriteAthenaField("CPU Name", CPUName);

	// - CPU Cores
	int numCPU = getNumCPUCores();
	WriteAthenaField("CPU Cores", numCPU);

	// - GPU0 Name
	std::vector<HardwareResources::Device> allDevices = HardwareResources::GetAllDevices();
	std::string GPU0Name = allDevices[0].name;
	WriteAthenaField("GPU0 Name", GPU0Name);

	// - GPU1 Name
	std::vector<std::string> GPU1Name; // list GPU 0-15
	GPU1Name.reserve(allDevices.size());
	for (HardwareResources::Device& device : allDevices)
		GPU1Name.push_back(device.name);
	WriteAthenaField("GPU1 Name", GPU1Name);

	// - device used
	int renderDevice = RenderStampUtils::GetRenderDevice();
	switch (renderDevice)
	{
		case RenderStampUtils::RPR_RENDERDEVICE_CPUONLY:
		{
			WriteAthenaField("CPU Enabled", true);
			WriteAthenaField("GPU0 Enabled", false);
			break;
		}

		case RenderStampUtils::RPR_RENDERDEVICE_GPUONLY:
		{
			WriteAthenaField("CPU Enabled", false);
			WriteAthenaField("GPU0 Enabled", true);
			break;
		}

		default: // CPU+GPU
			WriteAthenaField("CPU Enabled", true);
			WriteAthenaField("GPU0 Enabled", true);
	}

	std::vector<bool> gpusUsed;
	MIntArray devicesUsing;
	MGlobal::executeCommand("optionVar -q RPR_DevicesSelected", devicesUsing);
	size_t numDevices = std::min<size_t>(devicesUsing.length(), allDevices.size());

	for (size_t idx = 0; idx < numDevices; ++idx)
		gpusUsed.push_back(devicesUsing[(unsigned int)idx] != 0);

	WriteAthenaField("GPU1 Enabled", gpusUsed);

	// polygon count
	WriteAthenaField("Num Polygons", GetScenePolyCount());

	// render resolution
	std::vector<unsigned int> imgRes = { m_width, m_height };
	WriteAthenaField("Resolution", imgRes);

	// render result
<<<<<<< HEAD
	switch (m_context->m_lastRenderResultState)
=======
	header.str(std::string());
	header.clear();
	header << "End status";

	data_field.str(std::string());
	data_field.clear();

	switch (m_contextPtr->m_lastRenderResultState)
>>>>>>> master
	{
		case FireRenderContext::COMPLETED:
		{
			WriteAthenaField("End status", "successfull | completed");
			break;
		}

		case FireRenderContext::CANCELED:
		{
			WriteAthenaField("End status", "successfull | cancelled");
			break;
		}

		case FireRenderContext::CRASHED:
		{
			WriteAthenaField("End status", "failed | crashed");
			break;
		}

		default:
			WriteAthenaField("End status", "failed | error!");
	}

	// locale
	const char* currLocale = std::setlocale(LC_NUMERIC, "");
	WriteAthenaFieldAsString("OS Locale", currLocale);

	// lights
<<<<<<< HEAD
	WriteAthenaField("Lights Count", m_context->GetScene().LightObjectCount());
=======
	header.str(std::string());
	header.clear();
	header << "Lights count";

	data_field.str(std::string());
	data_field.clear();
	int countLights = m_contextPtr->GetScene().ShapeObjectCount();
	data_field << countLights;

	pAthenaWrapper->WriteField(header.str(), data_field.str());
>>>>>>> master

	// time and date
	auto curr = std::chrono::system_clock::now();
	std::time_t currTime = std::chrono::system_clock::to_time_t(curr);
	WriteAthenaField("Stop Time", std::string(std::ctime(&currTime)) );

	std::time_t renderStartTime = std::chrono::system_clock::to_time_t(m_context->m_lastRenderStartTime);
	WriteAthenaField("Start Time", std::string(std::ctime(&renderStartTime)) );

	// aov's
	static std::map<unsigned int, std::string> aovNames =
	{
		 {RPR_AOV_COLOR, "RPR_AOV_COLOR"}
		,{RPR_AOV_OPACITY, "RPR_AOV_OPACITY" }
		,{RPR_AOV_WORLD_COORDINATE, "RPR_AOV_WORLD_COORDINATE" }
		,{RPR_AOV_UV, "RPR_AOV_UV" }
		,{RPR_AOV_MATERIAL_IDX, "RPR_AOV_MATERIAL_IDX" }
		,{RPR_AOV_GEOMETRIC_NORMAL, "RPR_AOV_GEOMETRIC_NORMAL" }
		,{RPR_AOV_SHADING_NORMAL, "RPR_AOV_SHADING_NORMAL" }
		,{RPR_AOV_DEPTH, "RPR_AOV_DEPTH" }
		,{RPR_AOV_OBJECT_ID, "RPR_AOV_OBJECT_ID" }
		,{RPR_AOV_OBJECT_GROUP_ID, "RPR_AOV_OBJECT_GROUP_ID" }
		,{RPR_AOV_SHADOW_CATCHER, "RPR_AOV_SHADOW_CATCHER" }
		,{RPR_AOV_BACKGROUND, "RPR_AOV_BACKGROUND" }
		,{RPR_AOV_EMISSION, "RPR_AOV_EMISSION" }
		,{RPR_AOV_VELOCITY, "RPR_AOV_VELOCITY" }
		,{RPR_AOV_DIRECT_ILLUMINATION, "RPR_AOV_DIRECT_ILLUMINATION" }
		,{RPR_AOV_INDIRECT_ILLUMINATION, "RPR_AOV_INDIRECT_ILLUMINATION"}
		,{RPR_AOV_AO, "RPR_AOV_AO" }
		,{RPR_AOV_DIRECT_DIFFUSE, "RPR_AOV_DIRECT_DIFFUSE" }
		,{RPR_AOV_DIRECT_REFLECT, "RPR_AOV_DIRECT_REFLECT" }
		,{RPR_AOV_INDIRECT_DIFFUSE, "RPR_AOV_INDIRECT_DIFFUSE" }
		,{RPR_AOV_INDIRECT_REFLECT, "RPR_AOV_INDIRECT_REFLECT" }
		,{RPR_AOV_REFRACT, "RPR_AOV_REFRACT" }
		,{RPR_AOV_VOLUME, "RPR_AOV_VOLUME" }
		,{RPR_AOV_LIGHT_GROUP0, "RPR_AOV_LIGHT_GROUP0" }
		,{RPR_AOV_LIGHT_GROUP1, "RPR_AOV_LIGHT_GROUP1" }
		,{RPR_AOV_LIGHT_GROUP2, "RPR_AOV_LIGHT_GROUP2" }
		,{RPR_AOV_LIGHT_GROUP3, "RPR_AOV_LIGHT_GROUP3" }
		,{RPR_AOV_DIFFUSE_ALBEDO, "RPR_AOV_DIFFUSE_ALBEDO" }
		,{RPR_AOV_VARIANCE, "RPR_AOV_VARIANCE" }
		,{RPR_AOV_VIEW_SHADING_NORMAL, "RPR_AOV_VIEW_SHADING_NORMAL" }
		,{RPR_AOV_REFLECTION_CATCHER, "RPR_AOV_REFLECTION_CATCHER" }
		,{RPR_AOV_MAX, "RPR_AOV_MAX" }
	};

	std::vector<std::string> aovsUsed;
	aovsUsed.reserve(aovNames.size());

	for (int aovID = 0; aovID != RPR_AOV_MAX; aovID++)
<<<<<<< HEAD
		if (m_context->isAOVEnabled(aovID))
			aovsUsed.push_back(aovNames[aovID]);
=======
		if (m_contextPtr->isAOVEnabled(aovID))
			data_field << aovNames[aovID] << "; ";
>>>>>>> master

	WriteAthenaField("AOVs Enabled", aovsUsed);

	// completed iterations
	WriteAthenaField("Samples", m_context->m_currentIteration);

	// textures
	size_t countTextures = 0;
	long long texturesSize = 0;
	std::tie(countTextures, texturesSize) = GeSceneTexturesCountAndSize();
	WriteAthenaField("Num Textures", countTextures);
	WriteAthenaField("Textures Size", texturesSize/1000);

	// ray depth
	WriteAthenaField("Ray Depth", m_globals.maxRayDepth);
	WriteAthenaField("Diffuse Ray Depth", m_globals.maxRayDepthDiffuse);
	WriteAthenaField("Reflection Ray Depth", m_globals.maxRayDepthGlossy);
	WriteAthenaField("Refraction Ray Depth", m_globals.maxRayDepthRefraction);
	WriteAthenaField("Shadow Ray Depth", m_globals.maxRayDepthShadow);

	// maya version
	MString mayaVer = MGlobal::mayaVersion();
	WriteAthenaFieldAsString("App Version", mayaVer.asChar());

	// denoiser
	static std::map<FireRenderGlobals::DenoiserType, std::string> denoiserName =
	{
		{FireRenderGlobals::kBilateral, "Bilateral"} ,
		{FireRenderGlobals::kLWR, "LWR"} ,
		{FireRenderGlobals::kEAW, "EAW"} ,
		{FireRenderGlobals::kML, "ML"} ,
	};

	bool isDenoiserEnabled = m_globals.denoiserSettings.enabled;
	WriteAthenaField("RIF Type", isDenoiserEnabled ? denoiserName[m_globals.denoiserSettings.type] : "Not Enabled");
}

<<<<<<< HEAD
std::tuple<size_t, long long> FireRenderProduction::GeSceneTexturesCountAndSize() const
{
	size_t data_size = 0;
	rprContextGetInfo(m_context->context(), RPR_CONTEXT_LIST_CREATED_IMAGES, 0, nullptr, &data_size);
	std::vector<rpr_image> images(data_size / sizeof(rpr_image));
	rprContextGetInfo(m_context->context(), RPR_CONTEXT_LIST_CREATED_IMAGES, data_size, images.data(), &data_size);

	long long texturesSize = 0;

	for (auto image : images) 
	{
		size_t data_size = 0;
		rprImageGetInfo(image, RPR_IMAGE_DATA_SIZEBYTE, 0, nullptr, &data_size);

		long long temp;
		rprImageGetInfo(image, RPR_IMAGE_DATA_SIZEBYTE, data_size, &temp, nullptr);

		texturesSize += temp;
	}
=======
	data_field.str(std::string());
	data_field.clear();
	data_field << m_contextPtr->m_currentIteration;
>>>>>>> master

	return std::make_tuple(images.size(), texturesSize);
}

size_t FireRenderProduction::GetScenePolyCount() const
{
	size_t shapeCount = 0;
	auto status = rprSceneGetInfo(m_contextPtr->scene(), RPR_SCENE_SHAPE_LIST, 0, nullptr, &shapeCount);
	shapeCount /= sizeof(rpr_shape);
	if (status != RPR_SUCCESS || shapeCount == 0) return 0;

	std::vector<rpr_shape> shapes(shapeCount);
	status = rprSceneGetInfo(m_contextPtr->scene(), RPR_SCENE_SHAPE_LIST, shapeCount * sizeof(rpr_shape), shapes.data(), nullptr);
	return std::accumulate(std::begin(shapes), std::end(shapes), (size_t)0, [](size_t accumulator, const rpr_shape shape) 
		{
			size_t polygonCount = 0;
			rprMeshGetInfo(shape, RPR_MESH_POLYGON_COUNT, sizeof(polygonCount), &polygonCount, nullptr);
			return accumulator + polygonCount;
		});
}

bool FireRenderProduction::RunOnViewportThread()
{
	RPR_THREAD_ONLY;

	switch (m_contextPtr->state)
	{
		// The context is exiting.
		case FireRenderContext::StateExiting:
		{
			m_rendersCount++;
			return false;
		}

		// The context is rendering.
		case FireRenderContext::StateRendering:
		{
			if (m_cancelled || m_contextPtr->keepRenderRunning() == false)
			{
				m_contextPtr->m_lastRenderResultState = (m_cancelled) ? FireRenderContext::CANCELED : FireRenderContext::COMPLETED;

				AthenaWrapper::GetAthenaWrapper()->StartNewFile();
				UploadAthenaData();
				
				AthenaWrapper::GetAthenaWrapper()->AthenaSendFile(pythonCallWrap);

				m_contextPtr->m_polycountLastRender = 0;

				stop();
				m_rendersCount++;

				return false;
			}

			try
			{	// Render.
				AutoMutexLock contextLock(m_contextLock);
				if (m_contextPtr->state != FireRenderContext::StateRendering) 
					return false;

				//m_context->m_lastRenderResultState = FireRenderContext::CRASHED; // need to set before crash happens

				RenderFullFrame();
			}
			catch (...)
			{
				m_contextPtr->m_lastRenderResultState = FireRenderContext::CRASHED;

				AthenaWrapper::GetAthenaWrapper()->StartNewFile();
				UploadAthenaData();

				AthenaWrapper::GetAthenaWrapper()->AthenaSendFile(pythonCallWrap);

				throw;
			}

			return true;
		}

		case FireRenderContext::StatePaused:
		case FireRenderContext::StateUpdating:
		default:
			return true;
	}
}

void FireRenderProduction::RenderTiles()
{
	TileRenderer tileRenderer;

	TileRenderInfo info;

	info.tilesFillType = TileRenderFillType::Normal;
	info.tileSizeX = m_globals.tileSizeX;
	info.tileSizeY = m_globals.tileSizeY;

	info.totalWidth = m_width;
	info.totalHeight = m_height;

	m_contextPtr->setSamplesPerUpdate(m_globals.completionCriteriaFinalRender.completionCriteriaMaxIterations);

	// we need to resetup camera because total width and height differs with tileSizeX and tileSizeY
	m_contextPtr->camera().TranslateCameraExplicit(info.totalWidth, info.totalHeight);

	tileRenderer.Render(*m_contextPtr, info, [this](RenderRegion& region, int progress)
	{
		// make proper size
		unsigned int width = region.getWidth();
		unsigned int height = region.getHeight();

		m_contextPtr->resize(width, height, true);

		m_aovs->setRegion(RenderRegion(width, height), region.getWidth(), region.getHeight());
		m_aovs->allocatePixels();

		m_contextPtr->render(false);

		// Read pixel data for the AOV displayed in the render
		// view. Flip the image so it's the right way up in the view.
		m_renderViewAOV->readFrameBuffer(*m_contextPtr, true);

		FireRenderThread::RunProcOnMainThread([this, region]()
		{
			// Update the Maya render view.

			MRenderView::updatePixels(region.left, region.right,
			region.bottom, region.top, m_renderViewAOV->pixels.get(), true);

			// Refresh the render view.
			MRenderView::refresh(region.left, region.right, region.bottom, region.top);

			if (rcWarningDialog.shown)
				rcWarningDialog.close();
		});

		m_contextPtr->setProgress(progress);

		bool isContinue = !m_cancelled;

		if (isContinue)
		{
			m_contextPtr->setStartedRendering();
		}

		return isContinue;
	}
	);

	AthenaWrapper::GetAthenaWrapper()->StartNewFile();
	UploadAthenaData();
	AthenaWrapper::GetAthenaWrapper()->AthenaSendFile(pythonCallWrap);

	int debugi = 1;
}

void FireRenderProduction::RenderFullFrame()
{
	m_contextPtr->render(false);

	m_contextPtr->updateProgress();

	// Read pixel data for the AOV displayed in the render
	// view. Flip the image so it's the right way up in the view.
	m_renderViewAOV->readFrameBuffer(*m_contextPtr, true);

	FireRenderThread::RunProcOnMainThread([this]()
	{
		// Update the Maya render view.
		m_renderViewAOV->sendToRenderView();

		if (rcWarningDialog.shown)
			rcWarningDialog.close();
	});

	// Ensure display gamma correction is enabled for image file output. It
	// may be disabled initially if it's not set to be applied to Maya views.
	m_contextPtr->enableDisplayGammaCorrection(m_globals);

	// _TODO Investigate this, looks like this call is performance waste. Why we need to read all AOVs on every render call ?
	m_aovs->readFrameBuffers(*m_contextPtr, false);

	if (GlobalRenderUtilsDataHolder::GetGlobalRenderUtilsDataHolder()->IsSavingIntermediateEnabled())
	{
		bool shouldSave = GlobalRenderUtilsDataHolder::GetGlobalRenderUtilsDataHolder()->ShouldSaveFrame(m_contextPtr->m_currentIteration);

		if (shouldSave)
		{
			bool colorOnly = true;
			unsigned int imageFormat = 8; // "jpg"
			MString filePath = GlobalRenderUtilsDataHolder::GetGlobalRenderUtilsDataHolder()->FolderPath().c_str();
			filePath += m_contextPtr->m_currentIteration;
			filePath += ".jpg";
			m_renderViewAOV->writeToFile(filePath, colorOnly, imageFormat);

			std::ofstream timeLoggingFile;
			timeLoggingFile.open(GlobalRenderUtilsDataHolder::GetGlobalRenderUtilsDataHolder()->FolderPath() + "time_log.txt", std::ofstream::out | std::ofstream::app);
			timeLoggingFile << m_contextPtr->m_currentIteration << " ";
			long numberOfClicks = clock() - GlobalRenderUtilsDataHolder::GetGlobalRenderUtilsDataHolder()->GetStartTime();
			double secondsSpentRendering = numberOfClicks / (double)CLOCKS_PER_SEC;
			timeLoggingFile << secondsSpentRendering << "s \n";

			timeLoggingFile.close();
		}
	}
}

void FireRenderProduction::setStopCallback(stop_callback callback)
{
	m_stopCallback = callback;
}

void FireRenderProduction::waitForIt()
{
	while (m_isRunning)
	{
		FireRenderThread::RunItemsQueuedForTheMainThread();

		this_thread::sleep_for(10ms);
	}
}

// -----------------------------------------------------------------------------
void FireRenderProduction::scheduleRenderViewUpdate()
{
	// Only schedule one update at a time.
	if (m_renderViewUpdateScheduled)
		return;

	// Schedule the update.
	MGlobal::executeCommandOnIdle("fireRender -ipr -updateRenderView", false);

	// Flag as scheduled.
	m_renderViewUpdateScheduled = true;
}


// Private Methods
// -----------------------------------------------------------------------------
void FireRenderProduction::startMayaRender()
{
	// Stop any active render.
	stopMayaRender();

	// Start a region render if required.
	if (m_isRegion)
		MRenderView::startRegionRender(m_width, m_height,
			m_region.left, m_region.right,
			m_region.bottom, m_region.top, false, true);
	// Otherwise, start a full render.
	else
		MRenderView::startRender(m_width, m_height, false, true);

	// Flag as started.
	m_renderStarted = true;
	m_cancelled = false;

	pause(false);
}

// -----------------------------------------------------------------------------
void FireRenderProduction::stopMayaRender()
{
	// Check that a render has started.
	if (!m_renderStarted)
		return;

	m_renderStarted = false;
}

// -----------------------------------------------------------------------------
void FireRenderProduction::readFrameBuffer()
{
	RPR_THREAD_ONLY;

	m_contextPtr->readFrameBuffer(m_pixels.data(),
		RPR_AOV_COLOR,
		m_contextPtr->width(),
		m_contextPtr->height(),
		m_region,
		true);
}

bool FireRenderProduction::mainThreadPump()
{
	MAIN_THREAD_ONLY;

	if (m_isRunning)
	{
		AutoMutexLock contextCreationLock(m_contextCreationLock);

		if (m_progressBars && m_contextPtr)
		{
			m_progressBars->update(m_contextPtr->getProgress());

			m_cancelled = m_progressBars->isCancelled();

			if (m_cancelled)
			{
				DebugPrint("Rendering canceled!");

				m_progressBars.reset();
			}
		}

		return !m_cancelled;
	}

	return false;
}

// -----------------------------------------------------------------------------
void FireRenderProduction::refreshContext()
{
#ifdef OPTIMIZATION_CLOCK
	auto start = std::chrono::steady_clock::now();
#endif

	if (!m_contextPtr->isDirty())
		return;

	try
	{
		m_contextPtr->Freshen(false,
			[this]() -> bool
		{
			return m_cancelled;
		});
	}
	catch (...)
	{
		stop();
		m_isRunning = false;
		m_error.set(current_exception());
	}

#ifdef OPTIMIZATION_CLOCK
	auto end = std::chrono::steady_clock::now();
	auto elapsed = duration_cast<milliseconds>(end - start);
	int ms = elapsed.count();
	LogPrint("time spent in refreshContext() = %d ms", ms);
#endif
}
